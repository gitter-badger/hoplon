// Generated by LiveScript 1.6.0
(function(){
  var reg, com, main, z, l, prettyError, R, cc, modflag, print, packageJ, x$, c, help, pe, name, arrange, show_stack, show_chain, map_fname_to_ctypes, StrArgLen, lit, StrEType, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  reg = require("./registry");
  com = reg.com, main = reg.main;
  z = com.z, l = com.l, prettyError = com.prettyError, R = com.R, cc = com.cc;
  modflag = reg.modflag;
  print = reg.print;
  packageJ = reg.packageJ;
  x$ = c = {};
  x$.ok = cc.greenBright;
  x$.er = cc.xterm(196);
  x$.warn = cc.xterm(209);
  x$.err = cc.redBright;
  x$.black = cc.xterm(8);
  help = c.black("[  docs] " + packageJ.homepage);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.takeLast(3, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  name = packageJ.name;
  print.log = {};
  print.log.def_fault = function(){
    return c.err("[error." + name + "]");
  };
  print.log.proto = function(){
    var state;
    state = this[modflag];
    if (state === undefined) {
      return c.er("[" + name + "]") + c.err("[state undefined]");
    }
    return print.log.main(state);
  };
  print.log.wrap = function(state){
    return function(){
      return print.log.main(state);
    };
  };
  print.log.prox = function(state){
    var inner, str;
    if (state === null) {
      return null;
    }
    if (state.lock) {
      return c.ok("[Function]");
    }
    if (state.vr.length === 0) {
      inner = "";
    } else {
      inner = "|" + state.vr.join("|");
    }
    str = R.join("", ["[" + name, inner, "]"]);
    return c.warn(str) + " []";
  };
  arrange = R.pipe(R.groupWith(R.equals), R.map(function(x){
    var name;
    name = x[0];
    switch (x.length) {
    case 1:
      return name;
    default:
      return name + "(" + x.length + ")";
    }
  }), function(x){
    return c.ok(x.join(" "));
  });
  print.log.main = function(state){
    var str, clr, put, arr;
    if (state.fault) {
      return c.err("[" + name + "|error]");
    }
    str = "";
    if (state.immutable) {
      str += "|immutable";
      clr = c.ok;
    } else {
      str += "|mutable";
      clr = c.warn;
    }
    if (state.apply) {
      str += "|apply";
    }
    put = clr(("[" + name) + str + "]");
    arr = arrange(state.str);
    str = put + " " + "[ " + arr + " ]";
    return str;
  };
  show_stack = function(){
    var E;
    l(help);
    E = pe.render(new Error());
    l(E);
  };
  print.fail = function(filename){
    return function(){
      l("[TEST ERROR] originating from module", "[" + packageJ.name + "]", "\n\n- 'npm test' failed at " + filename + ":");
      process.exitCode = 1;
    };
  };
  show_chain = function(inputStr, path, showArgs){
    var str, i$, len$, I;
    path == null && (path = []);
    showArgs == null && (showArgs = true);
    str = "";
    for (i$ = 0, len$ = inputStr.length; i$ < len$; ++i$) {
      I = inputStr[i$];
      str += "." + I + "(~)";
    }
    str = c.ok(str);
    if (showArgs) {
      str += (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = path).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push(c.warn("." + I));
        }
        return results$;
      }()).join("");
      str += c.er("(xx) <-- error within argument");
    } else {
      str += c.err((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = path).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push("." + I);
        }
        return results$;
      }()).join(""));
      str += c.er(" <-- error here.");
    }
    return str;
  };
  map_fname_to_ctypes = function(fname){
    switch (fname) {
    case 'ma':
      return 'ma';
    case 'ar':
    case 'arn':
      return 'ar';
    case 'wh':
    case 'whn':
      return 'wh';
    case 'arwh':
    case 'arwhn':
    case 'arnwhn':
      return 'arwh';
    case 'arma':
      return 'arma';
    }
  };
  StrArgLen = function(fname, ctype, eType){
    var data;
    data = (function(){
      switch (ctype) {
      case 'ma':
        return [1, 'function|[fun....]'];
      case 'wh':
        return [2, '(function,function|any)'];
      case 'arma':
        return [2, '(number|[num...],[fun....]'];
      case 'ar':
        return [2, '(number|[num...],function|any)'];
      case 'arwh':
        return [3, '(number|[num...],function,function|any)'];
      }
    }());
    switch (eType) {
    case 'many_args':
      return ["too many arguments", c.er("xx"), "only " + data[0] + " arguments accepted\n\ntype :: " + data[1]];
    case 'few_args':
      return ["too few arguments", c.er("xx"), "requires " + data[0] + " arguments\n\ntype : " + data[1]];
    }
  };
  lit = R.pipe(R.zipWith(function(x, f){
    switch (R.type(f)) {
    case 'Function':
      return f(x);
    default:
      return x;
    }
  }), R.join(""));
  StrEType = function(fname, eType){
    var ctype, init;
    ctype = map_fname_to_ctypes(fname);
    switch (eType) {
    case 'many_args':
    case 'few_args':
      return StrArgLen(fname, ctype, eType);
    }
    init = (function(){
      switch (ctype) {
      case 'ma':
        return c.er('function|[fun....]');
      case 'arma':
        switch (eType) {
        case 'first':
          return lit(["number", "|[num...],[fun....]"], [c.er, c.ok]);
        case 'array':
          return lit(["number", "|[num..]", ",[fun....]"], [c.ok, c.er, c.ok]);
        case 'not_function':
          return lit(["number|[num..]", ",[fun....]"], [c.ok, c.er]);
        }
        break;
      case 'ar':
        switch (eType) {
        case 'first':
          return lit(["number", "|[num...],function|any"], [c.er, c.ok]);
        case 'array':
          return lit(["number", "|[num..]", ",function|any"], [c.ok, c.er, c.ok]);
        }
        break;
      case 'wh':
        switch (eType) {
        case 'first':
          return lit(["function", ",function|any"], [c.er, c.ok]);
        case 'second':
          return lit(["function", "function|any"], [c.ok, c.er]);
        }
        break;
      case 'arwh':
        switch (eType) {
        case 'num':
          return lit(["number", "|[num..],function,function|any"], [c.er, c.ok]);
        case 'array':
          return lit(["number|", "[num..]", ",function,function|any"], [c.ok, c.er, c.ok]);
        case 'second':
          return lit(["number[num..],", "function", ",function|any"], [c.ok, c.er, c.ok]);
        }
      }
    }());
    init = lit(["(", init, ")"], [c.ok, null, c.ok]);
    return [init, 'One of the argument cannot be used by the function'];
  };
  print.typeError = function(data, fname, attribute){
    var ref$, long, type;
    ref$ = StrEType(fname, attribute), long = ref$[0], type = ref$[1];
    l(c.err("[" + packageJ.name + "][typeError] " + long));
    l('\n', show_chain(data, [fname]), '\n');
    l(c.black(type) + "\n");
    return show_stack();
  };
  print.not_array = function(data){
    l(c.err("[" + packageJ.name + "][typeError] first argument is not array like."));
    l('\n', lit(['unary', show_chain(arrayFrom$(data.str).concat(['def']), [])], [c.warn, 0]), '\n');
    l(lit(["unary namespace requires first argument to be array like.", "\n"], [c.black, 0]));
    return show_stack();
  };
  print.setting = function(type, path){
    var msg, vr, key;
    msg = (function(){
      switch (type) {
      case 'path_locked':
        return "all settings enabled.";
      case 'already_in_path':
        return "setting already enabled.";
      case 'not_in_opts':
        return "undefined option.";
      }
    }());
    l(lit([name + "][configError]", " " + msg], [c.err, c.warn]));
    vr = path[0], key = path[1];
    l('\n', lit([vr.join("."), ".", key], [c.ok, c.ok, c.er]), '\n');
    return show_stack();
  };
  print.route = function(arg$){
    var Er, data, ECLASS, whichE, info, __, fname, arg_placement;
    Er = arg$[0], data = arg$[1];
    ECLASS = Er[0], whichE = Er[1], info = Er[2];
    switch (ECLASS) {
    case 'input':
      __ = Er[0], fname = Er[1], arg_placement = Er[2];
      print.typeError(data, fname, arg_placement);
      break;
    case 'not_array':
      print.not_array(data);
      break;
    case 'setting':
      print.setting(Er[1], data);
      break;
    default:
      l(Er, data);
    }
  };
}).call(this);
