// Generated by LiveScript 1.6.0
(function(){
  var reg, com, main, z, l, R, c, esp, modflag, print, packageJ, help, lit, name, arrange, rmPaths, show_stack, show_chain, map_fname_to_ctypes, StrArgLen, StrEType, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  reg = require("./registry");
  com = reg.com, main = reg.main;
  z = com.z, l = com.l, R = com.R, c = com.c, esp = com.esp;
  modflag = reg.modflag;
  print = reg.print;
  packageJ = reg.packageJ;
  help = c.black("[  docs] " + packageJ.homepage);
  lit = R.pipe(R.zipWith(function(x, f){
    switch (R.type(f)) {
    case 'Function':
      return f(x);
    default:
      return x;
    }
  }), R.join(""));
  name = packageJ.name;
  print.log = {};
  print.log.def_fault = function(){
    return c.err("[error." + name + "]");
  };
  print.log.proto = function(){
    var state;
    state = this[modflag];
    if (state === undefined) {
      return c.er("[" + name + "]") + c.err("[state undefined]");
    }
    return print.log.main(state);
  };
  print.log.wrap = function(state){
    return function(){
      return print.log.main(state);
    };
  };
  print.log.prox = function(state){
    var inner, str;
    if (state === null) {
      return null;
    }
    if (state.lock) {
      return c.ok("[Function]");
    }
    if (state.vr.length === 0) {
      inner = "";
    } else {
      inner = "|" + state.vr.join("|");
    }
    str = R.join("", ["[" + name, inner, "]"]);
    return c.warn(str) + " []";
  };
  arrange = R.pipe(R.groupWith(R.equals), R.map(function(x){
    var name;
    name = x[0];
    switch (x.length) {
    case 1:
      return name;
    default:
      return name + "(" + x.length + ")";
    }
  }), function(x){
    return c.ok(x.join(" "));
  });
  print.log.main = function(state){
    var str, clr, put, arr;
    if (state.fault) {
      return c.err("[" + name + "|error]");
    }
    str = "";
    if (state.immutable) {
      str += "|immutable";
      clr = c.ok;
    } else {
      str += "|mutable";
      clr = c.warn;
    }
    if (state.apply) {
      str += "|apply";
    }
    put = clr(("[" + name) + str + "]");
    arr = arrange(state.str);
    str = put + " " + "[ " + arr + " ]";
    return str;
  };
  rmPaths = R.find(function(x){
    return x === 'hoplon' || x === 'node_modules';
  });
  show_stack = function(){
    var E, i$, len$, I, lineNumber, fileName, functionName, columnNumber, path, first, second, results$ = [];
    l(help + "\n");
    E = esp.parse(new Error());
    for (i$ = 0, len$ = E.length; i$ < len$; ++i$) {
      I = E[i$];
      lineNumber = I.lineNumber, fileName = I.fileName, functionName = I.functionName, columnNumber = I.columnNumber;
      path = fileName.split("/");
      first = path[0], second = path[1];
      if (rmPaths(path)) {
        continue;
      }
      if (first === 'internal' && second === 'modules') {
        continue;
      }
      if (functionName === 'Object.<anonymous>') {
        functionName = "";
      }
      results$.push(l(lit(["  - ", R.last(path), ":", lineNumber, " ", functionName, "\n    ", fileName + ":", lineNumber, ":" + columnNumber + "\n"], [0, c.warn, 0, c.er, 0, 0, 0, c.black, c.er, c.black])));
    }
    return results$;
  };
  print.fail = function(filename){
    return function(){
      l("[TEST ERROR] originating from module", "[" + packageJ.name + "]", "\n\n- 'npm test' failed at " + filename + ":");
      process.exitCode = 1;
    };
  };
  show_chain = function(inputStr, path, showArgs){
    var str, i$, len$, I;
    path == null && (path = []);
    showArgs == null && (showArgs = true);
    str = "";
    for (i$ = 0, len$ = inputStr.length; i$ < len$; ++i$) {
      I = inputStr[i$];
      str += "." + I + "(~)";
    }
    str = c.ok(str);
    if (showArgs) {
      str += (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = path).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push(c.warn("." + I));
        }
        return results$;
      }()).join("");
      str += c.er("(xx) <-- error within argument");
    } else {
      str += c.err((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = path).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push("." + I);
        }
        return results$;
      }()).join(""));
      str += c.er(" <-- error here.");
    }
    return str;
  };
  map_fname_to_ctypes = function(fname){
    switch (fname) {
    case 'ma':
      return 'ma';
    case 'ar':
    case 'arn':
      return 'ar';
    case 'wh':
    case 'whn':
      return 'wh';
    case 'arwh':
    case 'arwhn':
    case 'arnwhn':
    case 'arma':
      return 'arwh';
    }
  };
  StrArgLen = function(fname, ctype, eType){
    var data;
    data = (function(){
      switch (ctype) {
      case 'ma':
        return [1, 'function|[fun....]'];
      case 'wh':
        return [2, '(function,function|any)'];
      case 'ar':
        return [2, '(number|[num...],function|any)'];
      case 'arwh':
        return [3, '(number|[num...],function,function|any)'];
      }
    }());
    switch (eType) {
    case 'many_args':
      return ["too many arguments", c.er("  only " + data[0] + " arguments \n\n  accepted type :: " + data[1] + " ")];
    case 'few_args':
      return ["too few arguments", c.er("  requires " + data[0] + " arguments \n\n  type : " + data[1] + " ")];
    }
  };
  StrEType = function(fname, eType){
    var ctype, init;
    ctype = map_fname_to_ctypes(fname);
    switch (eType) {
    case 'many_args':
    case 'few_args':
      return StrArgLen(fname, ctype, eType);
    }
    init = (function(){
      switch (ctype) {
      case 'ma':
        return c.er('function|[fun....]');
      case 'arma':
        switch (eType) {
        case 'first':
          return lit(["number", "|[num...],[fun....]"], [c.er, c.ok]);
        case 'array':
          return lit(["number", "|[num..]", ",[fun....]"], [c.ok, c.er, c.ok]);
        case 'not_function':
          return lit(["number|[num..]", ",[fun....]"], [c.ok, c.er]);
        }
        break;
      case 'ar':
        switch (eType) {
        case 'first':
          return lit(["number", "|[num...],function|any"], [c.er, c.ok]);
        case 'array':
          return lit(["number", "|[num..]", ",function|any"], [c.ok, c.er, c.ok]);
        }
        break;
      case 'wh':
        switch (eType) {
        case 'first':
          return lit(["function", ",function|any"], [c.er, c.ok]);
        case 'second':
          return lit(["function", "function|any"], [c.ok, c.er]);
        }
        break;
      case 'arwh':
        switch (eType) {
        case 'num':
          return lit(["number", "|[num..],function,function|any"], [c.er, c.ok]);
        case 'array':
          return lit(["number|", "[num..]", ",function,function|any"], [c.ok, c.er, c.ok]);
        case 'second':
          return lit(["number[num..],", "function", ",function|any"], [c.ok, c.er, c.ok]);
        }
      }
    }());
    init = lit(["(", init, ")"], [c.ok, null, c.ok]);
    return [init, 'One of the argument cannot be used by the function'];
  };
  print.typeError = function(data, fname, attribute){
    var ref$, long, type;
    ref$ = StrEType(fname, attribute), long = ref$[0], type = ref$[1];
    l(c.err("[" + packageJ.name + "][typeError] " + long));
    l('\n', show_chain(data, [fname]), '\n');
    l(c.black(type) + "\n");
    return show_stack();
  };
  print.not_array = function(data){
    l(c.err("[" + packageJ.name + "][typeError] first argument is not array like."));
    l('\n', lit(['unary', show_chain(arrayFrom$(data.str).concat(['def']), [])], [c.warn, 0]), '\n');
    l(lit(["unary namespace requires first argument to be array like.", "\n"], [c.black, 0]));
    return show_stack();
  };
  print.setting = function(type, path){
    var msg, vr, key;
    msg = (function(){
      switch (type) {
      case 'path_locked':
        return "all settings enabled.";
      case 'already_in_path':
        return "setting already enabled.";
      case 'not_in_opts':
        return "undefined option.";
      }
    }());
    l(lit([name + "][configError]", " " + msg], [c.err, c.warn]));
    vr = path[0], key = path[1];
    l('\n', lit([vr.join("."), ".", key], [c.ok, c.ok, c.er]), '\n');
    return show_stack();
  };
  print.state_undef = function(type){
    l(lit(["[" + name + "][Error]"], [c.err]));
    l(lit(["\n  ." + type], [c.warn]));
    l(lit(["\n  Javascript does not allow referencing of .prototype function.\n"], [c.black]));
    return show_stack();
  };
  print.route = function(arg$){
    var Er, data, ECLASS, whichE, info, __, fname, arg_placement;
    Er = arg$[0], data = arg$[1];
    ECLASS = Er[0], whichE = Er[1], info = Er[2];
    switch (ECLASS) {
    case 'input':
      __ = Er[0], fname = Er[1], arg_placement = Er[2];
      print.typeError(data, fname, arg_placement);
      break;
    case 'not_array':
      print.not_array(data);
      break;
    case 'setting':
      print.setting(Er[1], data);
      break;
    case 'state_undef':
      print.state_undef(data);
      break;
    default:
      l(Er, data);
    }
  };
}).call(this);
