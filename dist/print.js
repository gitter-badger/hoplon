// Generated by LiveScript 1.6.0
(function(){
  var ref$, l, z, chalk, R, j, prettyError, reg, printE, pJ, x$, c, help, pe, pkgname, show_stack, gench, get_full_str, StrArgLen, StrEType;
  ref$ = require("./common"), l = ref$.l, z = ref$.z, chalk = ref$.chalk, R = ref$.R, j = ref$.j, prettyError = ref$.prettyError;
  reg = require("./registry");
  printE = reg.printE;
  pJ = reg.packageJ;
  x$ = c = {};
  x$.ok = chalk.green.bold;
  x$.er = chalk.hex("FF0000");
  x$.warn = chalk.hex("FFFFCD");
  x$.black = chalk.rgb(128, 128, 128).bold;
  help = c.black("[  docs] " + pJ.homepage);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.drop(6, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  pkgname = pJ.name;
  show_stack = function(){
    var E;
    l(help);
    E = pe.render(new Error());
    return l(E);
  };
  printE.fail = function(filename){
    return function(){
      l("[TEST ERROR] originating from module", "[" + pkgname + "]", "\n\n- 'npm test' failed at " + filename + ":");
      process.exitCode = 1;
    };
  };
  printE.log = function(path, data){
    var str, i$, ref$, len$, I, ref1$, fname, lens;
    str = "";
    for (i$ = 0, len$ = (ref$ = data.fns).length; i$ < len$; ++i$) {
      I = i$;
      ref1$ = ref$[i$], fname = ref1$[0], lens = ref1$[1][0];
      str += c.ok('- ' + fname);
      switch (fname) {
      case 'ar':
      case 'arn':
      case 'arwh':
      case 'arwhn':
      case 'arnwhn':
        str += c.warn(' [ ' + lens.join(' ') + ' ]');
      }
      if (I < data.fns.length - 1) {
        str += '\n';
      }
    }
    str += "\n-----\n";
    str += c.ok('def :');
    if (data.def) {
      str += c.ok(' [function]');
    } else {
      str += c.warn(' undefined');
    }
    return str;
  };
  gench = R.pipe(R.map(function(x){
    return x + "(~)";
  }), R.join('.'), function(x){
    return c.ok(x);
  });
  printE.api_not_defined = function(str, attr){
    l(c.er("[" + pkgname + "][api.error]"));
    l('\n', gench(str) + c.er('.' + attr));
    l(c.warn("\n" + c.er('.' + attr) + " is not defined within the module.\n"));
    return show_stack();
  };
  printE.path_too_long = function(str, attr){
    l(c.er("[" + pkgname + "][api.error] path is too long"));
    l('\n', gench(str) + c.er('.' + attr.join('.') + '(~)'), '\n');
    show_stack();
  };
  printE.def_is_defined = function(str){
    l(c.er("[" + pkgname + "][api.error]"));
    l('\n', gench(str) + c.er('.def(~)'), '\n');
    l(c.warn("default function can't be defined more than once.\n"));
    show_stack();
  };
  printE.all_match_fail = function(){
    l(c.er("[" + pkgname + "][pattern.matching.error] unable to match arguments"));
    l(c.warn("\n - direct call only matches arguments with following acceptable types :\n\n    (function)------(maps to)----> .def\n\n    (number,function)------------> .args\n\n    (function,function)----------> .when\n\n    (number,function,function)---> .args_when\n"));
    show_stack();
  };
  get_full_str = function(fname){
    var full_name;
    full_name = (function(){
      switch (fname) {
      case 'wh':
        return 'when';
      case 'whn':
        return 'when_not';
      case 'ar':
        return 'arg';
      case 'arn':
        return 'arg_not';
      case 'arwh':
        return 'arg_when';
      case 'arwhn':
        return 'arg_when_not';
      case 'arnwhn':
        return 'arg_not_when_not';
      case 'def':
        return 'default';
      }
    }());
    return full_name;
  };
  StrArgLen = function(info, type){
    var data;
    data = (function(){
      switch (type) {
      case 'f':
        return [1, '(function)'];
      case 'nf':
        return [2, '(number|[num...],function)'];
      case 'ff':
        return [2, '(function,function)'];
      case 'nff':
        return [3, '(number|[num...],function,function)'];
      }
    }());
    switch (info) {
    case 'many_args':
      return ["too many arguments", c.er("~"), "only " + data[0] + " argument " + data[1] + " accepted."];
    case 'few_args':
      return ["too few arguments", c.er("~"), "requires " + data[0] + " arguments " + data[1] + "."];
    }
  };
  StrEType = function(eType){
    var ref$, type, info, parts;
    ref$ = eType.split("."), type = ref$[0], info = ref$[1];
    switch (info) {
    case 'many_args':
    case 'few_args':
      return StrArgLen(info, type);
    }
    parts = (function(){
      switch (type) {
      case 'f':
        switch (info) {
        case 'fun':
          return [c.ok('(') + c.er('function') + c.ok(')'), c.er('fun')];
        }
        break;
      case 'nf':
        switch (info) {
        case 'num':
          return [c.ok("(") + c.er('number|array') + c.ok(',function') + c.ok(')'), c.er('num|array') + c.ok(',fun')];
        case 'fun':
          return [c.ok('(number,') + c.er('function') + c.ok(')'), c.ok('num,') + c.er('fun')];
        case 'array':
          return [c.ok("(") + c.er('[num..]') + c.ok(',function') + c.ok(')'), c.er('[num..]') + c.ok(',fun')];
        }
        break;
      case 'ff':
        switch (info) {
        case 'first':
          return [c.ok('(') + c.er('function') + c.ok(',function') + c.ok(')'), c.er('fun') + c.ok(',fun')];
        case 'second':
          return [c.ok('(') + c.ok('function,') + c.er('function') + c.ok(')'), c.ok('fun,') + c.er('fun')];
        }
        break;
      case 'nff':
        switch (info) {
        case 'num':
          return [c.ok('(') + c.er('number|array') + c.ok(',function,function') + c.ok(')'), c.er('num|arr') + c.ok(',fun,fun')];
        case 'array':
          return [c.ok('(') + c.er('[num..]') + c.ok(',function,function') + c.ok(')'), c.er('[num..]') + c.ok(',fun,fun')];
        case 'first':
          return [c.ok('(') + c.ok('array/number,') + c.er("function") + c.ok(",function)"), c.ok('num|arr') + c.er("fun") + c.ok(',fun')];
        case 'second':
          return [c.ok("(num|arr,function,") + c.er("function") + c.ok(")"), c.ok('num|arr,fun,') + c.ok('fun')];
        }
      }
    }());
    parts.push('One of the argument cannot be used by the function');
    return parts;
  };
  printE.typeError = function(fname, eType, str){
    var ref$, long, short, type, oname, ePart;
    ref$ = StrEType(eType), long = ref$[0], short = ref$[1], type = ref$[2];
    l(c.er("[" + pkgname + "][typeError] " + long));
    oname = get_full_str(fname);
    ePart = c.warn('.' + oname) + c.warn("(") + short + c.warn(")") + c.warn(" <-- error here");
    l('\n', gench(str) + ePart, '\n');
    l(c.black(type) + "\n");
    return show_stack();
  };
  printE.route = function(str, Er){
    var __, outerE, _, eName, attr, fname, eType;
    __ = Er[0], outerE = Er[1];
    switch (outerE) {
    case 'path':
      _ = Er[0], __ = Er[1], eName = Er[2], attr = Er[3];
      printE[eName](str, attr);
      break;
    case 'input':
      _ = Er[0], __ = Er[1], fname = Er[2], eType = Er[3];
      printE.typeError(fname, eType, str);
    }
  };
  module.exports = reg.printE;
}).call(this);
