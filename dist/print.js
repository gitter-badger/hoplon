// Generated by LiveScript 1.6.0
(function(){
  var reg, com, main, z, chalk, l, prettyError, R, modflag, print, packageJ, x$, c, help, pe, show_stack, show_chain, map_fname_to_ctypes, StrArgLen, StrEType;
  reg = require("./registry");
  com = reg.com, main = reg.main;
  z = com.z, chalk = com.chalk, l = com.l, prettyError = com.prettyError, R = com.R;
  modflag = reg.modflag;
  print = reg.print;
  packageJ = reg.packageJ;
  x$ = c = {};
  x$.ok = chalk.green.bold;
  x$.er = chalk.hex("FF0000");
  x$.warn = chalk.hex("FFFFCD");
  x$.err = chalk.red;
  x$.black = chalk.rgb(128, 128, 128).bold;
  help = c.black("[  docs] " + packageJ.homepage);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.takeLast(5, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  print.log = {};
  print.log.proto = function(){
    return print.log.main(this[modflag]);
  };
  print.log.wrap = function(state){
    return function(){
      return print.log.main(state);
    };
  };
  print.log.def_fault = function(){
    return c.err("[error." + packageJ.name + "]");
  };
  print.log.main = function(state){
    var str, I, i$, ref$, len$, ref1$, fname, data, spans, fdata, type, lens, ECLASS, innertxt;
    str = "";
    if (state === undefined) {
      return (function(){
        var results$ = [];
        for (I in main) {
          results$.push(I);
        }
        return results$;
      }());
    }
    if (state.mutelog) {
      if (state.fault) {
        return c.err("[error." + packageJ.name + "]");
      }
      if (state.immutable) {
        return c.ok("[immutable." + packageJ.name + "]");
      } else {
        return c.warn("[mutable." + packageJ.name + "]");
      }
    }
    switch (state.immutable) {
    case true:
      str += c.ok("[   immutable   ]");
      break;
    case false:
      str += c.warn("[    mutable    ]");
    }
    str += "\n";
    str += "-----------------";
    str += "\n";
    for (i$ = 0, len$ = (ref$ = state.fns).length; i$ < len$; ++i$) {
      I = i$;
      ref1$ = ref$[i$], fname = ref1$.fname, data = ref1$.data;
      str += c.ok('- ' + fname);
      switch (fname) {
      case 'ar':
      case 'arn':
      case 'arwh':
      case 'arnwh':
      case 'arwhn':
      case 'arma':
      case 'arnwhn':
        spans = data[0], fdata = data[1];
        type = spans[0], lens = spans[1];
        switch (type) {
        case 'n':
          str += c.warn(' [ ' + lens + ' ]');
          break;
        case 'a':
          str += c.warn(' [ ' + lens.join(' ') + ' ]');
        }
      }
      if (I < state.fns.length - 1) {
        str += "\n";
      }
    }
    if (state.fault) {
      ref$ = state.fault, ECLASS = ref$[0], fname = ref$[1], type = ref$[2];
      str += "\n";
      innertxt = [ECLASS, type].join(" ");
      str += c.er("- ERROR : | " + fname + " | " + innertxt);
    }
    str += "\n";
    str += "-----------------";
    if (state.def) {
      str += c.ok(" \n- def");
    }
    return str;
  };
  show_stack = function(){
    var E;
    l(help);
    E = pe.render(new Error());
    l(E);
  };
  print.fail = function(filename){
    return function(){
      l("[TEST ERROR] originating from module", "[" + packageJ.name + "]", "\n\n- 'npm test' failed at " + filename + ":");
      process.exitCode = 1;
    };
  };
  show_chain = function(data, path, showArgs){
    var str, i$, ref$, len$, I;
    path == null && (path = []);
    showArgs == null && (showArgs = true);
    str = "";
    for (i$ = 0, len$ = (ref$ = data.str).length; i$ < len$; ++i$) {
      I = ref$[i$];
      str += "." + I + "(~)";
    }
    str = c.ok(str);
    if (showArgs) {
      str += (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = path).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push(c.warn("." + I));
        }
        return results$;
      }()).join("");
      str += c.er("(xx) <-- error within argument");
    } else {
      str += c.err((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = path).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push("." + I);
        }
        return results$;
      }()).join(""));
      str += c.er(" <-- error here.");
    }
    return str;
  };
  map_fname_to_ctypes = function(fname){
    switch (fname) {
    case 'ma':
      return 'ma';
    case 'ar':
    case 'arn':
      return 'ar';
    case 'wh':
    case 'whn':
      return 'wh';
    case 'arwh':
    case 'arwhn':
    case 'arnwhn':
      return 'arwh';
    case 'arma':
      return 'arma';
    }
  };
  StrArgLen = function(fname, ctype, eType){
    var data;
    data = (function(){
      switch (ctype) {
      case 'ma':
        return [1, 'function|[fun....]'];
      case 'wh':
        return [2, '(function,function|any)'];
      case 'arma':
        return [2, '(number|[num...],[fun....]'];
      case 'ar':
        return [2, '(number|[num...],function|any)'];
      case 'arwh':
        return [3, '(number|[num...],function,function|any)'];
      }
    }());
    switch (eType) {
    case 'many_args':
      return ["too many arguments", c.er("xx"), "only " + data[0] + " arguments accepted\n\ntype :: " + data[1]];
    case 'few_args':
      return ["too few arguments", c.er("xx"), "requires " + data[0] + " arguments\n\ntype : " + data[1]];
    }
  };
  StrEType = function(fname, eType){
    var ctype, parts;
    ctype = map_fname_to_ctypes(fname);
    switch (eType) {
    case 'many_args':
    case 'few_args':
      return StrArgLen(fname, ctype, eType);
    }
    parts = (function(){
      switch (ctype) {
      case 'ma':
        return [c.er('function|[fun....]')];
      case 'arma':
        switch (eType) {
        case 'first':
          return [c.er("number") + c.ok('|[num...],[fun....]')];
        case 'array':
          return [c.ok("number") + c.er('|[num..]') + c.ok(',[fun....]')];
        case 'not_function':
          return [c.ok("number|[num..]") + c.er(',[fun....]')];
        }
        break;
      case 'ar':
        switch (eType) {
        case 'first':
          return [c.er("number") + c.ok('|[num...],function|any')];
        case 'array':
          return [c.ok("number") + c.er('|[num..]') + c.ok(',function|any')];
        }
        break;
      case 'wh':
        switch (eType) {
        case 'first':
          return [c.er('function') + c.ok(',function|any')];
        case 'second':
          return [c.ok('function,') + c.er('function|any')];
        }
        break;
      case 'arwh':
        switch (eType) {
        case 'num':
          return [c.er('number') + c.ok('|[num..],function,function|any')];
        case 'array':
          return [c.ok('number|') + c.er('[num..]') + c.ok(',function,function|any')];
        case 'second':
          return [c.ok('number[num..],') + c.er("function") + c.ok(",function|any")];
        }
      }
    }());
    parts[0] = c.ok("(") + parts[0] + c.ok(")");
    parts.push('One of the argument cannot be used by the function');
    return parts;
  };
  print.typeError = function(data, fname, attribute){
    var ref$, long, type;
    ref$ = StrEType(fname, attribute), long = ref$[0], type = ref$[1];
    l(c.err("[" + packageJ.name + "][typeError] " + long));
    l('\n', show_chain(data, [fname]), '\n');
    l(c.black(type) + "\n");
    return show_stack();
  };
  print.route = function(arg$){
    var Er, data, ECLASS, whichE, info, __, fname, arg_placement;
    Er = arg$[0], data = arg$[1];
    ECLASS = Er[0], whichE = Er[1], info = Er[2];
    switch (ECLASS) {
    case 'input':
      __ = Er[0], fname = Er[1], arg_placement = Er[2];
      print.typeError(data, fname, arg_placement);
      break;
    default:
      l(Er);
    }
  };
}).call(this);
