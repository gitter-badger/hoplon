// Generated by LiveScript 1.6.0
(function(){
  var reg, com, printE, packageJ, l, z, chalk, R, j, prettyError, pkgname, x$, c, help, pe, show_stack, gench, get_full_str, map_fname_to_types, StrArgLen, StrEType;
  reg = require("./registry");
  com = reg.com, printE = reg.printE, packageJ = reg.packageJ;
  l = com.l, z = com.z, chalk = com.chalk, R = com.R, j = com.j, prettyError = com.prettyError;
  printE = reg.printE;
  pkgname = packageJ.name;
  x$ = c = {};
  x$.ok = chalk.green.bold;
  x$.er = chalk.hex("FF0000");
  x$.warn = chalk.hex("FFFFCD");
  x$.black = chalk.rgb(128, 128, 128).bold;
  help = c.black("[  docs] " + packageJ.homepage);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.drop(6, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  show_stack = function(){
    var E;
    l(help);
    E = pe.render(new Error());
    return l(E);
  };
  printE.fail = function(filename){
    return function(){
      l("[TEST ERROR] originating from module", "[" + pkgname + "]", "\n\n- 'npm test' failed at " + filename + ":");
      process.exitCode = 1;
    };
  };
  printE.log = function(path, data){
    var str, i$, ref$, len$, I, ref1$, fname, lens;
    str = "";
    for (i$ = 0, len$ = (ref$ = data.fns).length; i$ < len$; ++i$) {
      I = i$;
      ref1$ = ref$[i$], fname = ref1$.fname, lens = ref1$.args[0];
      str += c.ok('- ' + fname);
      switch (fname) {
      case 'ar':
      case 'arn':
      case 'arwh':
      case 'arwhn':
      case 'arnwhn':
        str += c.warn(' [ ' + lens.join(' ') + ' ]');
      }
      if (I < data.fns.length - 1) {
        str += '\n';
      }
    }
    if (data.fault) {
      str += '\n';
      str += c.er("- " + (data.fault[1] + ' <[' + data.fault[2] + ']>'));
    }
    str += "\n-----\n";
    str += c.ok('def :');
    if (data.def) {
      str += c.ok(' [function]');
    } else {
      str += c.warn(' undefined');
    }
    return str;
  };
  gench = R.pipe(R.map(function(x){
    return x + "(~)";
  }), R.join('.'), function(x){
    return c.ok(x);
  });
  printE.api_not_defined = function(str, attr){
    l(c.er("[" + pkgname + "][api.error]"));
    l('\n', gench(str) + c.er('.' + attr));
    l(c.warn("\n" + c.er('.' + attr) + " is not defined within the module.\n"));
    return show_stack();
  };
  printE.path_too_long = function(str, attr){
    l(c.er("[" + pkgname + "][api.error] path is too long"));
    l('\n', gench(str) + c.er('.' + attr.join('.') + '(~)'), '\n');
    show_stack();
  };
  printE.def_is_defined = function(str){
    l(c.er("[" + pkgname + "][api.error]"));
    l('\n', gench(str) + c.er('.def(~)'), '\n');
    l(c.warn("default function can't be defined more than once.\n"));
    show_stack();
  };
  printE.all_match_fail = function(){
    l(c.er("[" + pkgname + "][pattern.matching.error] unable to match arguments"));
    l(c.black("\n - direct call only matches arguments with following acceptable types :\n\n    (number,function/array)------------> " + c.warn(".args") + "\n\n    (function,function/array)----------> " + c.warn(".when") + "\n\n    (number,function,function/array)---> " + c.warn(".args_when") + "\n"));
    show_stack();
  };
  get_full_str = function(fname){
    switch (fname) {
    case 'ma':
      return 'match';
    case 'wh':
      return 'when';
    case 'whn':
      return 'when_not';
    case 'ar':
      return 'arg';
    case 'arn':
      return 'arg_not';
    case 'arwh':
      return 'arg_when';
    case 'arwhn':
      return 'arg_when_not';
    case 'arnwhn':
      return 'arg_not_when_not';
    case 'def':
      return 'default';
    }
  };
  map_fname_to_types = function(fname){
    switch (fname) {
    case 'ma':
      return 'ma';
    case 'def':
      return 'def';
    case 'ar':
    case 'arn':
      return 'ar';
    case 'wh':
    case 'whn':
      return 'wh';
    case 'arwh':
    case 'arwhn':
    case 'arnwhn':
      return 'arwh';
    }
  };
  StrArgLen = function(fname, eType){
    var data;
    data = (function(){
      switch (fname) {
      case 'ma':
        return [1, '(function)'];
      case 'def':
        return [1, "(function|unknown)"];
      case 'ar':
      case 'arn':
        return [2, '(number|[num...],function|array)'];
      case 'wh':
      case 'whn':
        return [2, '(function,function|array)'];
      case 'arwh':
      case 'arwhn':
      case 'arnwhn':
        return [3, '(number|[num...],function,function|array)'];
      }
    }());
    switch (eType) {
    case 'many_args':
      return ["too many arguments", c.er("~"), "only " + data[0] + " arguments accepted\ntype : " + data[1]];
    case 'few_args':
      return ["too few arguments", c.er("~"), "requires " + data[0] + " arguments\ntype : " + data[1]];
    }
  };
  StrEType = function(fname, eType){
    var ctype, parts;
    switch (eType) {
    case 'many_args':
    case 'few_args':
      return StrArgLen(fname, eType);
    }
    ctype = map_fname_to_types(fname);
    parts = (function(){
      switch (ctype) {
      case 'ma':
        return [c.er('function'), c.er('<!--!>')];
      case 'def':
        return [c.er('function|unknown'), c.er('fun')];
      case 'ar':
        switch (eType) {
        case 'num':
          return [c.er('number|[num...]') + c.ok(',function|array'), c.er('num|[num...]') + c.ok(',fun|arr')];
        case 'second':
          return [c.ok('(number|[num...],') + c.er('function|array'), c.ok('num|[num...],') + c.er('fun|array')];
        case 'array':
          return [c.er('[num..]') + c.ok(',function|array'), c.er('[num..]') + c.ok(',fun|array')];
        }
        break;
      case 'wh':
        switch (eType) {
        case 'first':
          return [c.er('function') + c.ok(',function|array'), c.er('fun') + c.ok(',fun|array')];
        case 'second':
          return [c.ok('function,') + c.er('function|array'), c.ok('fun,') + c.er('fun|array')];
        }
        break;
      case 'arwh':
        switch (eType) {
        case 'num':
          return [c.er('number|[num..]') + c.ok(',function,function|array'), c.er('num|[num..]') + c.ok(',fun,fun|array')];
        case 'array':
          return [c.er('[num..]') + c.ok(',function,function|array'), c.er('[num..]') + c.ok(',fun,fun|array')];
        case 'second':
          return [c.ok('number[num..],') + c.er("function") + c.ok(",function|array"), c.ok('num|[num..]') + c.er("fun") + c.ok(',fun|array')];
        case 'third':
          return [c.ok("num|[num..],function,") + c.er("function|array"), c.ok('num|[num..],fun,') + c.er('fun|array')];
        }
      }
    }());
    parts[0] = c.ok("(") + parts[0] + c.ok(")");
    parts.push('One of the argument cannot be used by the function');
    return parts;
  };
  printE.typeError = function(fname, placement, str){
    var ref$, long, short, type, oname, ePart;
    ref$ = StrEType(fname, placement), long = ref$[0], short = ref$[1], type = ref$[2];
    l(c.er("[" + pkgname + "][typeError] " + long));
    oname = get_full_str(fname);
    ePart = c.warn('.' + oname) + c.warn("(") + short + c.warn(")") + c.warn(" <-- error here");
    l('\n', gench(str) + ePart, '\n');
    l(c.black(type) + "\n");
    return show_stack();
  };
  printE.route = function(str, Er){
    var whichE, fname, type;
    whichE = Er[0], fname = Er[1], type = Er[2];
    switch (whichE) {
    case 'path':
      printE[fname](str, type);
      break;
    case 'input':
      printE.typeError(fname, type, str);
    }
  };
}).call(this);
