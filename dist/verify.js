// Generated by LiveScript 1.6.0
(function(){
  var com, reg, z, R, verify, betterTypeof, num, try_matching, map_fname;
  com = require("./common");
  reg = require("./registry");
  z = com.z, R = com.R;
  verify = reg.verify;
  betterTypeof = function(x){
    var type;
    type = typeof x;
    if (type === 'object') {
      if (Array.isArray(x)) {
        return 'array';
      } else {
        return 'object';
      }
    } else {
      return type;
    }
  };
  verify.fun = function(args){
    if (args.length > 1) {
      return ['fault', 'f.many_args'];
    }
    if (args.length === 0) {
      return ['fault', 'f.few_args'];
    }
    switch (betterTypeof(args[0])) {
    case 'function':
      return ['f', args];
    case 'array':
      return ['a', args];
    default:
      return ['fault', 'f.fun'];
    }
  };
  num = function(args){
    var i$, ref$, len$, i, v;
    if (typeof args[0] === 'number') {
      args[0] = [args[0]];
      return ['number'];
    } else if (Array.isArray(args[0])) {
      for (i$ = 0, len$ = (ref$ = args[0]).length; i$ < len$; ++i$) {
        i = i$;
        v = ref$[i$];
        if (!(typeof v === 'number')) {
          return ['fault', 'array'];
        }
        return ['array'];
      }
    } else {
      return ['fault', 'num'];
    }
  };
  verify.numfun = function(args){
    var ref$, cont, type;
    if (args.length > 2) {
      return ['fault', 'nf.many_args'];
    }
    if (args.length < 2) {
      return ['fault', 'nf.few_args'];
    }
    ref$ = num(args), cont = ref$[0], type = ref$[1];
    switch (cont) {
    case 'fault':
      return ['fault', 'nf.' + type];
    }
    switch (betterTypeof(args[1])) {
    case 'function':
      return ['nf', args];
    case 'array':
      return ['na', args];
    default:
      return ['fault', 'nf.fun'];
    }
  };
  verify.funfun = function(args){
    if (args.length > 2) {
      return ['fault', 'ff.many_args'];
    }
    if (args.length < 2) {
      return ['fault', 'ff.few_args'];
    }
    if (!(typeof args[0] === 'function')) {
      return ['fault', 'ff.first'];
    }
    switch (betterTypeof(args[1])) {
    case 'function':
      return ['ff', args];
    case 'array':
      return ['fa', args];
    default:
      return ['fault', 'ff.second'];
    }
  };
  verify.numfunfun = function(args){
    var ref$, cont, type;
    if (args.length > 3) {
      return ['fault', 'nff.many_args'];
    }
    if (args.length < 3) {
      return ['fault', 'nff.few_args'];
    }
    ref$ = num(args), cont = ref$[0], type = ref$[1];
    switch (cont) {
    case 'fault':
      return ['fault', 'nff.' + type];
    }
    if (!(typeof args[1] === 'function')) {
      return ['fault', 'nff.second'];
    }
    switch (betterTypeof(args[2])) {
    case 'function':
      return ['nff', args];
    case 'array':
      return ['nfa', args];
    default:
      return ['fault', 'nff.third'];
    }
  };
  try_matching = R.pipe(function(x){
    return [x];
  }, R.ap([verify.numfun, verify.funfun, verify.numfunfun, verify.fun]), R.reject(function(arg$){
    var state;
    state = arg$[0];
    return state === 'fault';
  }));
  map_fname = function(fname){
    var shorthand, V, validator;
    shorthand = (function(){
      switch (fname) {
      case 'wh':
      case 'when':
        return 'wh';
      case 'whn':
      case 'when_not':
        return 'whn';
      case 'ar':
      case 'arg':
      case 'args':
        return 'ar';
      case 'arn':
      case 'arg_not':
      case 'args_not':
        return 'arn';
      case 'arwh':
      case 'arg_when':
      case 'args_when':
        return 'arwh';
      case 'arwhn':
      case 'arg_when_not':
      case 'args_when_not':
        return 'arwhn';
      case 'arnwhn':
      case 'arg_not_when_not':
      case 'args_not_when_not':
        return 'arnwhn';
      case 'def':
      case 'default':
        return 'def';
      default:
        return 'fault';
      }
    }());
    switch (shorthand) {
    case 'fault':
      return ['fault', ['path', 'api_not_defined', fname]];
    }
    V = verify;
    validator = (function(){
      switch (shorthand) {
      case 'wh':
        return V.funfun;
      case 'whn':
        return V.funfun;
      case 'ar':
        return V.numfun;
      case 'arn':
        return V.numfun;
      case 'arwh':
        return V.numfunfun;
      case 'arwhn':
        return V.numfunfun;
      case 'arnwhn':
        return V.numfunfun;
      case 'def':
        return V.fun;
      }
    }());
    return [shorthand, validator];
  };
  verify.main = function(path, args, data){
    var rets, ref$, patt, clean, part, ret, fname, validator, type;
    switch (path.length) {
    case 0:
      if (data.fns.length === 0 && data.def === null) {
        rets = try_matching(args);
        switch (rets.length) {
        case 0:
          return ['fault', ['path', 'all_match_fail']];
        default:
          ref$ = rets[0], patt = ref$[0], clean = ref$[1];
          part = (function(){
            switch (patt) {
            case 'f':
            case 'a':
              return ['def', patt, clean];
            case 'nf':
            case 'na':
              return ['ar', patt, clean];
            case 'ff':
            case 'fa':
              return ['wh', patt, clean];
            case 'nff':
            case 'nfa':
              return ['arwh', patt, clean];
            }
          }());
          return ['chain', part];
        }
      } else {
        return ['resolve', args];
      }
    case 1:
      ret = map_fname(path[0]);
      fname = ret[0], validator = ret[1];
      switch (fname) {
      case 'fault':
        return ret;
      }
      ret = validator(args);
      type = ret[0], data = ret[1];
      switch (type) {
      case 'fault':
        return ['fault', ['input', fname, data]];
      }
      switch (fname) {
      case 'def':
        switch (data.ldef) {
        case true:
          return ['fault', ['path', 'def_is_defined']];
        }
      }
      return ['chain', [fname, type, data]];
    default:
      return ['fault', ['path', 'path_too_long', path]];
    }
  };
}).call(this);
