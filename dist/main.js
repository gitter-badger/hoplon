// Generated by LiveScript 1.6.0
(function(){
  var com, binapi, l, SI, z, reg, noop, sim, j, verify, printE, merge, resolve, chain, entry, data, hoplon;
  com = require("./common");
  require("./verify");
  require("./print");
  binapi = com.binapi, l = com.l, SI = com.SI, z = com.z, reg = com.reg, noop = com.noop, sim = com.sim, j = com.j;
  verify = reg.verify, printE = reg.printE;
  merge = function(data, p){
    return SI.merge(data, p, {
      merger: sim.concatArrayMerger
    });
  };
  resolve = function(data, input){
    var arglen, i$, ref$, len$, ref1$, fname, args, type, validator, f, lens, j$, len1$, I;
    arglen = input.length;
    for (i$ = 0, len$ = (ref$ = data.fns).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], fname = ref1$.fname, args = ref1$.args, type = ref1$.type;
      switch (fname) {
      case 'wh':
        validator = args[0], f = args[1];
        if (validator.apply(null, input)) {
          switch (type) {
          case 'ff':
            return f.apply(null, input);
          case 'fa':
            return f;
          }
        }
        break;
      case 'ar':
        lens = args[0], f = args[1];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            switch (type) {
            case 'nf':
              return f.apply(null, input);
            case 'na':
              return f;
            }
          }
        }
        break;
      case 'whn':
        validator = args[0], f = args[1];
        if (!validator.apply(null, input)) {
          switch (type) {
          case 'ff':
            return f.apply(null, input);
          case 'fa':
            return f;
          }
        }
        break;
      case 'arn':
        lens = args[0], f = args[1];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (!(arglen === I)) {
            switch (type) {
            case 'nf':
              return f.apply(null, input);
            case 'na':
              return f;
            }
          }
        }
        break;
      case 'arwh':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            if (validator.apply(null, input)) {
              switch (type) {
              case 'nff':
                return f.apply(null, input);
              case 'nfa':
                return f;
              }
              return f.apply(null, input);
            }
          }
        }
        break;
      case 'arwhn':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            if (!validator.apply(null, input)) {
              switch (type) {
              case 'nff':
                return f.apply(null, input);
              case 'nfa':
                return f;
              }
            }
          }
        }
        break;
      case 'arnwhn':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (!(arglen === I)) {
            if (!validator.apply(null, input)) {
              switch (type) {
              case 'nff':
                return f.apply(null, input);
              case 'nfa':
                return f;
              }
            }
          }
        }
      }
    }
    if (data.def) {
      switch (data.def.type) {
      case 'a':
        return data.def.o;
      case 'f':
        return (ref$ = data.def).o.apply(ref$, input);
      }
    }
  };
  chain = function(state, arg$){
    var fname, type, args, part, neo, f;
    fname = arg$[0], type = arg$[1], args = arg$[2];
    part = {};
    part.str = [fname];
    neo = (function(){
      switch (fname) {
      case 'def':
        f = args[0];
        part.ldef = true;
        part.def = {
          type: type,
          o: f
        };
        return merge(state, part);
      default:
        part.fns = [{
          fname: fname,
          type: type,
          args: args
        }];
        return merge(state, part);
      }
    }());
    return binapi(entry, neo);
  };
  entry = function(path, user, state){
    var ret, cont, info;
    if (state.fault) {
      return binapi(entry, state);
    }
    ret = verify.main(path, user, state);
    cont = ret[0], info = ret[1];
    switch (cont) {
    case 'resolve':
      return resolve(state, info);
    case 'chain':
      return chain(state, info);
    case 'fault':
      printE.route(state.str, info);
      return binapi(entry, merge(state, {
        fault: info
      }));
    }
  };
  entry.log = printE.log;
  data = {
    fns: [],
    def: null,
    ldef: false,
    fault: false,
    str: []
  };
  hoplon = binapi(entry, SI(data));
  module.exports = hoplon;
}).call(this);
