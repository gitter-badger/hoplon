// Generated by LiveScript 1.6.0
(function(){
  var reg, com, already_created, verify, modflag, print, main, l, z, R, uic, init, settle, tightloop, looper, handle, genfun, props, hoplon;
  reg = require("./registry");
  require("./print");
  require("./verify");
  com = reg.com, already_created = reg.already_created, verify = reg.verify, modflag = reg.modflag, print = reg.print, main = reg.main;
  l = com.l, z = com.z, R = com.R, uic = com.uic;
  init = {
    str: [],
    fns: [],
    def: null,
    fault: false,
    unary: false,
    immutable: false
  };
  settle = function(F, A){
    var ftype, f;
    ftype = F[0], f = F[1];
    switch (ftype) {
    case 'f':
      return f.apply(null, A);
    case 's':
      return f;
    }
  };
  tightloop = function(state){
    return function(){
      var first, arglen, I, fns, terminate, ref$, fname, data, validator, fin, F, spans, ret0, ret1, ret2, ret3, Jn, J, ret, funs, def;
      if (state.unary) {
        first = arguments[0];
        switch (R.type(first)) {
        case 'Arguments':
        case 'Array':
          arglen = first.length;
          break;
        default:
          print.route([['not_array'], state]);
          return undefined;
        }
      } else {
        arglen = arguments.length;
      }
      I = 0;
      fns = state.fns;
      terminate = fns.length;
      do {
        ref$ = fns[I], fname = ref$.fname, data = ref$.data;
        switch (fname) {
        case 'wh':
          validator = data[0], fin = data[1];
          if (validator.apply(null, arguments)) {
            return settle(fin, arguments);
          }
          break;
        case 'whn':
          validator = data[0], F = data[1];
          if (!validator.apply(null, arguments)) {
            return settle(F, arguments);
          }
          break;
        case 'ar':
          spans = data[0], F = data[1];
          if (spans[arglen]) {
            return settle(F, arguments);
          }
          break;
        case 'arn':
          spans = data[0], F = data[1];
          if (!spans[arglen]) {
            return settle(F, arguments);
          }
          break;
        case 'arwh':
          spans = data[0], validator = data[1], F = data[2];
          if (spans[arglen] && validator.apply(null, arguments)) {
            return settle(fin, arguments);
          }
          break;
        case 'ma':
          switch (data.length) {
          case 1:
            ret0 = data[0].apply(data, arguments);
            if (ret0) {
              return ret0;
            }
            break;
          case 2:
            ret0 = data[0].apply(data, arguments);
            if (ret0) {
              return ret0;
            }
            ret1 = data[1].apply(data, arguments);
            if (ret1) {
              return ret1;
            }
            break;
          case 3:
            ret0 = data[0].apply(data, arguments);
            if (ret0) {
              return ret0;
            }
            ret1 = data[1].apply(data, arguments);
            if (ret1) {
              return ret1;
            }
            ret2 = data[2].apply(data, arguments);
            if (re2) {
              return ret2;
            }
            break;
          case 4:
            ret0 = data[0].apply(data, arguments);
            if (ret0) {
              return ret0;
            }
            ret1 = data[1].apply(data, arguments);
            if (ret1) {
              return ret1;
            }
            ret2 = data[2].apply(data, arguments);
            if (re2) {
              return ret2;
            }
            ret3 = data[3].apply(data, arguments);
            if (re3) {
              return ret3;
            }
            break;
          default:
            Jn = data.length;
            J = 0;
            do {
              ret = data[J].apply(data, arguments);
              if (ret) {
                return ret;
              }
              J += 1;
            } while (J < Jn);
          }
          break;
        case 'arma':
          if (data[0][arglen]) {
            funs = data[1];
            switch (funs.length) {
            case 1:
              ret0 = funs[0].apply(funs, arguments);
              if (ret0) {
                return ret0;
              }
              break;
            case 2:
              ret0 = funs[0].apply(funs, arguments);
              if (ret0) {
                return ret0;
              }
              ret1 = funs[1].apply(funs, arguments);
              if (ret1) {
                return ret1;
              }
              break;
            case 3:
              ret0 = funs[0].apply(funs, arguments);
              if (ret0) {
                return ret0;
              }
              ret1 = funs[1].apply(funs, arguments);
              if (ret1) {
                return ret1;
              }
              ret2 = funs[2].apply(funs, arguments);
              if (re2) {
                return ret2;
              }
              break;
            case 4:
              ret0 = funs[0].apply(funs, arguments);
              if (ret0) {
                return ret0;
              }
              ret1 = funs[1].apply(funs, arguments);
              if (ret1) {
                return ret1;
              }
              ret2 = funs[2].apply(funs, arguments);
              if (re2) {
                return ret2;
              }
              ret3 = funs[3].apply(funs, arguments);
              if (re3) {
                return ret3;
              }
              break;
            default:
              Jn = data.length;
              J = 0;
              do {
                ret = funs[J].apply(funs, arguments);
                if (ret) {
                  return ret;
                }
                J += 1;
              } while (J < Jn);
            }
          }
          break;
        case 'arwhn':
          spans = data[0], validator = data[1], F = data[2];
          if (spans[arglen] && !validator.apply(null, arguments)) {
            return settle(F, arguments);
          }
          break;
        case 'arnwh':
          spans = data[0], validator = data[1], F = data[2];
          if (!spans[arglen] && validator.apply(null, arguments)) {
            return settle(F, arguments);
          }
          break;
        case 'arnwhn':
          spans = data[0], validator = data[1], F = data[2];
          if (!(spans[arglen] && validator.apply(null, arguments))) {
            return settle(F, arguments);
          }
        }
        I += 1;
      } while (I < terminate);
      def = state.def;
      if (def) {
        switch (def[0]) {
        case 'f':
          return def[1].apply(def, arguments);
        case 's':
          return def[1];
        }
      }
    };
  };
  looper = function(state){
    var instance;
    instance = Object.create(main);
    instance[modflag] = state;
    return instance;
  };
  handle = {};
  handle.fault = function(self, data, fname){
    var state, FT, neo;
    state = self[modflag];
    FT = ['input', fname, data];
    print.route([FT, state]);
    neo = Object.assign({}, state, {
      fault: FT
    });
    return looper(neo);
  };
  handle.ok = function(self, data, fname){
    var state, fns, neo;
    state = self[modflag];
    if (state.immutable || state.str.length === 0) {
      fns = state.fns.concat({
        fname: fname,
        data: data
      });
      neo = Object.assign({}, state, {
        fns: fns,
        str: state.str.concat(fname)
      });
      return looper(neo);
    } else {
      state.fns.push({
        fname: fname,
        data: data
      });
      state.str.push(fname);
      neo = state;
      return self;
    }
  };
  handle.def = {};
  handle.def.fault = function(){
    return null;
  };
  handle.def.fault[uic] = print.log.def_fault;
  handle.def.ok = function(self, data){
    var state, neo, F;
    state = self[modflag];
    neo = Object.assign({}, state, {
      def: data,
      str: state.str
    });
    F = tightloop(neo);
    F[uic] = print.log.wrap(neo);
    return F;
  };
  genfun = function(vfun, fname){
    return function(){
      var state, ref$, zone, data;
      state = this[modflag];
      if (state.fault) {
        return this;
      }
      ref$ = vfun(arguments), zone = ref$[0], data = ref$[1];
      return handle[zone](this, data, fname);
    };
  };
  main[uic] = print.log.proto;
  main.def = function(){
    var state, ref$, zone, data;
    state = this[modflag];
    if (state.fault) {
      return handle.def.fault;
    }
    ref$ = verify.def(arguments), zone = ref$[0], data = ref$[1];
    return handle.def.ok(this, data);
  };
  props = ['ma', 'arma', 'wh', 'ar', 'whn', 'arn', 'arwh', 'arnwh', 'arwhn', 'arnwhn'];
  R.reduce(function(ob, prop){
    ob[prop] = genfun(verify.getvfun(prop), prop);
    return ob;
  }, main, props);
  hoplon = looper(init);
  hoplon.immutable = looper(Object.assign({}, init, {
    immutable: true
  }));
  hoplon.unary = looper(Object.assign({}, init, {
    unary: true
  }));
  hoplon.immutable.unary = looper(Object.assign({}, init, {
    immutable: true,
    unary: true
  }));
  hoplon.unary.immutable = looper(Object.assign({}, init, {
    immutable: true,
    unary: true
  }));
  Object.freeze(hoplon);
  reg.hoplon = hoplon;
  module.exports = hoplon;
}).call(this);
