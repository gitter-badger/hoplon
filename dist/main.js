// Generated by LiveScript 1.6.0
(function(){
  var reg, com, already_created, verify, self, print, main, l, z, R, util_inspect_custom, init, settle, looper, handle, genfun, props, hoplon;
  reg = require("./registry");
  require("./print");
  require("./verify");
  com = reg.com, already_created = reg.already_created, verify = reg.verify, self = reg.self, print = reg.print, main = reg.main;
  l = com.l, z = com.z, R = com.R;
  util_inspect_custom = com.util_inspect_custom;
  init = {
    str: [],
    fns: [],
    def: null,
    ldef: false,
    fault: false
  };
  settle = function(F, A){
    var ftype, f;
    ftype = F[0], f = F[1];
    switch (ftype) {
    case 'f':
      return f.apply(null, A);
    case 'o':
      return f.pipe.apply(f, A);
    case 's':
      return f;
    }
  };
  main.pipe = function(){
    var state, arglen, i$, ref$, len$, ref1$, fname, data, J, I, ret, validator, fin, spans, F, ltype, lens, def;
    state = this[self];
    if (state === undefined) {
      print.route(void 8, ['state_undefined']);
      return null;
    }
    arglen = arguments.length;
    for (i$ = 0, len$ = (ref$ = state.fns).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], fname = ref1$.fname, data = ref1$.data;
      switch (fname) {
      case 'ma':
        J = data.length;
        I = 0;
        switch (data.length) {
        case 1:
          ret = settle(data[0], arguments);
          if (ret) {
            return ret;
          }
          break;
        default:
          while (I < J) {
            ret = settle(data[I], arguments);
            if (ret) {
              return ret;
            }
            I += 1;
          }
        }
        break;
      case 'wh':
        validator = data[0], fin = data[1];
        if (settle(validator, arguments)) {
          return settle(fin, arguments);
        }
        break;
      case 'whn':
        validator = data[0], fin = data[1];
        if (!settle(validator, arguments)) {
          return settle(fin, arguments);
        }
        break;
      case 'ar':
        spans = data[0], F = data[1];
        ltype = spans[0], lens = spans[1];
        switch (ltype) {
        case 'n':
          if (lens === arglen) {
            return settle(F, arguments);
          }
          break;
        case 'a':
          J = data.length;
          I = 0;
          while (I < J) {
            if (I === arglen) {
              return settle(F, arguments);
            }
            I += 1;
          }
        }
        break;
      case 'arn':
        spans = data[0], fin = data[1];
        ltype = spans[0], lens = spans[1];
        switch (ltype) {
        case 'n':
          if (!(lens === arglen)) {
            return settle(fin, arguments);
          }
          break;
        case 'a':
          J = lens.length;
          I = 0;
          while (I < J) {
            if (!(lens[I] === arglen)) {
              return settle(fin, arguments);
            }
            I += 1;
          }
        }
        break;
      case 'arwh':
        spans = data[0], validator = data[1], fin = data[2];
        ltype = spans[0], lens = spans[1];
        switch (ltype) {
        case 'n':
          if (lens === arglen) {
            if (settle(validator, arguments)) {
              return settle(fin, arguments);
            }
          }
          break;
        case 'a':
          J = lens.length;
          I = 0;
          while (I < J) {
            if (lens[I] === arglen) {
              if (settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
            I += 1;
          }
        }
        break;
      case 'arwhn':
        spans = data[0], validator = data[1], fin = data[2];
        ltype = spans[0], lens = spans[1];
        switch (ltype) {
        case 'n':
          if (lens === arglen) {
            if (!settle(validator, arguments)) {
              return settle(fin, arguments);
            }
          }
          break;
        case 'a':
          J = lens.length;
          I = 0;
          while (I < J) {
            if (lens[I] === arglen) {
              if (!settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
            I += 1;
          }
        }
        break;
      case 'arnwh':
        spans = data[0], validator = data[1], fin = data[2];
        ltype = spans[0], lens = spans[1];
        switch (ltype) {
        case 'n':
          if (!(lens === arglen)) {
            if (settle(validator, arguments)) {
              return settle(fin, arguments);
            }
          }
          break;
        case 'a':
          J = lens.length;
          I = 0;
          while (I < J) {
            if (!(lens[I] === arglen)) {
              if (settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
            I += 1;
          }
        }
        break;
      case 'arnwhn':
        spans = data[0], validator = data[1], fin = data[2];
        ltype = spans[0], lens = spans[1];
        switch (ltype) {
        case 'n':
          if (!(lens === arglen)) {
            if (!settle(validator, arguments)) {
              return settle(fin, arguments);
            }
          }
          break;
        case 'a':
          J = lens.length;
          I = 0;
          while (I < J) {
            if (!(lens[I] === arglen)) {
              if (!settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
            I += 1;
          }
        }
      }
    }
    def = state.def;
    if (def) {
      return settle(def, arguments);
    }
  };
  main.wrap = function(){
    var state;
    state = this;
    return function(){
      return main.pipe.apply(state, arguments);
    };
  };
  looper = function(state){
    var instance;
    instance = Object.create(main);
    already_created.add(instance);
    instance[self] = state;
    return instance;
  };
  handle = {};
  handle.fault = function(state, data, fname){
    var FT, neo;
    FT = ['input', fname, data];
    print.route(state, FT);
    neo = Object.assign({}, state, {
      fault: FT
    });
    return looper(neo);
  };
  handle.ok = function(state, data, fname){
    var fns, neo;
    fns = state.fns.concat({
      fname: fname,
      data: data
    });
    neo = Object.assign({}, state, {
      fns: fns,
      str: state.str.concat(fname)
    });
    return looper(neo);
  };
  handle.def = {};
  handle.def.ok = function(state, data){
    var neo;
    neo = Object.assign({}, state, {
      def: data,
      str: state.str.concat('def'),
      ldef: true
    });
    return looper(neo);
  };
  handle.def.fault = handle.fault;
  genfun = function(vfun, fname){
    return function(){
      var state, ref$, zone, data;
      state = this[self];
      if (state.fault) {
        return this;
      }
      ref$ = vfun(arguments), zone = ref$[0], data = ref$[1];
      return handle[zone](state, data, fname);
    };
  };
  main[util_inspect_custom] = print.log;
  main.def = function(){
    var state, faultType, neo, ref$, zone, data;
    state = this[self];
    if (state.fault) {
      return this;
    }
    if (state.ldef) {
      faultType = ['def_is_defined', 'def', ''];
      print.route(state, faultType);
      neo = Object.assign({}, state, {
        fault: faultType
      });
      return looper(neo);
    }
    ref$ = verify.def(arguments), zone = ref$[0], data = ref$[1];
    return handle.def[zone](state, data, 'def');
  };
  props = ['ma', 'wh', 'ar', 'whn', 'arn', 'arwh', 'arnwh', 'arwhn', 'arnwhn'];
  R.reduce(function(ob, prop){
    ob[prop] = genfun(verify.getvfun(prop), prop);
    return ob;
  }, main, props);
  hoplon = looper(init);
  reg.hoplon = hoplon;
  module.exports = hoplon;
}).call(this);
