// Generated by LiveScript 1.6.0
(function(){
  var reg, com, already_created, verify, modflag, print, main, l, z, R, uic, init, settle, tightloop, looper, handle, genfun, props, hoplon;
  reg = require("./registry");
  require("./print");
  require("./verify");
  com = reg.com, already_created = reg.already_created, verify = reg.verify, modflag = reg.modflag, print = reg.print, main = reg.main;
  l = com.l, z = com.z, R = com.R, uic = com.uic;
  init = {
    str: [],
    fns: [],
    def: null,
    fault: false,
    immutable: false,
    mutelog: false
  };
  settle = function(F, A){
    var ftype, f;
    ftype = F[0], f = F[1];
    switch (ftype) {
    case 'f':
      return f.apply(null, A);
    case 's':
      return f;
    }
  };
  tightloop = function(state){
    return function(){
      var arglen, i$, ref$, len$, ref1$, fname, data, validator, fin, ret, J, I, spans, F, ltype, lens, has, funs, M, N, def;
      arglen = arguments.length;
      for (i$ = 0, len$ = (ref$ = state.fns).length; i$ < len$; ++i$) {
        ref1$ = ref$[i$], fname = ref1$.fname, data = ref1$.data;
        switch (fname) {
        case 'wh':
          validator = data[0], fin = data[1];
          if (validator.apply(null, arguments)) {
            return settle(fin, arguments);
          }
          break;
        case 'ma':
          switch (data.length) {
          case 1:
            ret = data[0].apply(data, arguments);
            if (ret) {
              return ret;
            }
            break;
          default:
            J = data.length;
            I = 0;
            while (I < J) {
              ret = data[I].apply(data, arguments);
              if (ret) {
                return ret;
              }
              I += 1;
            }
          }
          break;
        case 'whn':
          validator = data[0], fin = data[1];
          if (!validator.apply(null, arguments)) {
            return settle(fin, arguments);
          }
          break;
        case 'ar':
          spans = data[0], F = data[1];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              return settle(F, arguments);
            }
            break;
          case 'a':
            J = lens.length;
            I = 0;
            while (I < J) {
              if (lens[I] === arglen) {
                return settle(F, arguments);
              }
              I += 1;
            }
          }
          break;
        case 'arn':
          spans = data[0], fin = data[1];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (!(lens === arglen)) {
              return settle(fin, arguments);
            }
            break;
          case 'a':
            J = lens.length;
            I = 0;
            has = false;
            while (I < J) {
              if (lens[I] === arglen) {
                has = true;
              }
              I += 1;
            }
            if (!has) {
              return settle(fin, arguments);
            }
          }
          break;
        case 'arwh':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              if (validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            J = lens.length;
            I = 0;
            while (I < J) {
              if (lens[I] === arglen) {
                if (validator.apply(null, arguments)) {
                  return settle(fin, arguments);
                }
              }
              I += 1;
            }
          }
          break;
        case 'arma':
          spans = data[0], funs = data[1];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              switch (funs.length) {
              case 1:
                ret = funs[0].apply(funs, arguments);
                if (ret) {
                  return ret;
                }
                break;
              default:
                J = funs.length;
                I = 0;
                while (I < J) {
                  ret = funs[I].apply(funs, arguments);
                  if (ret) {
                    return ret;
                  }
                  I += 1;
                }
              }
            }
            break;
          case 'a':
            spans = data[0], funs = data[1];
            ltype = spans[0], lens = spans[1];
            J = lens.length;
            I = 0;
            while (I < J) {
              if (lens[I] === arglen) {
                switch (funs.length) {
                case 1:
                  ret = funs[0].apply(funs, arguments);
                  if (ret) {
                    return ret;
                  }
                  break;
                default:
                  M = funs.length;
                  N = 0;
                  while (N < M) {
                    ret = funs[N].apply(funs, arguments);
                    if (ret) {
                      return ret;
                    }
                    N += 1;
                  }
                }
              }
              I += 1;
            }
          }
          break;
        case 'arwhn':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              if (!validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            J = lens.length;
            I = 0;
            while (I < J) {
              if (lens[I] === arglen) {
                if (!validator.apply(null, arguments)) {
                  return settle(fin, arguments);
                }
              }
              I += 1;
            }
          }
          break;
        case 'arnwh':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (!(lens === arglen)) {
              if (settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            J = lens.length;
            I = 0;
            has = false;
            while (I < J) {
              if (lens[I] === arglen) {
                has = true;
              }
              I += 1;
            }
            if (!has) {
              if (settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
          }
          break;
        case 'arnwhn':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (!(lens === arglen)) {
              if (!validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            J = lens.length;
            I = 0;
            has = false;
            while (I < J) {
              if (lens[I] === arglen) {
                has = true;
              }
              I += 1;
            }
            if (!has) {
              if (!validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
          }
        }
      }
      def = state.def;
      if (def) {
        switch (def[0]) {
        case 'f':
          return def[1].apply(def, arguments);
        case 's':
          return def[1];
        }
      }
    };
  };
  looper = function(state){
    var instance;
    instance = Object.create(main);
    instance[modflag] = state;
    return instance;
  };
  handle = {};
  handle.fault = function(self, data, fname){
    var state, FT, neo;
    state = self[modflag];
    FT = ['input', fname, data];
    print.route([FT, state]);
    neo = Object.assign({}, state, {
      fault: FT
    });
    return looper(neo);
  };
  handle.ok = function(self, data, fname){
    var state, fns, neo;
    state = self[modflag];
    if (state.immutable || state.str.length === 0) {
      fns = state.fns.concat({
        fname: fname,
        data: data
      });
      neo = Object.assign({}, state, {
        fns: fns,
        str: state.str.concat(fname)
      });
      return looper(neo);
    } else {
      state.fns.push({
        fname: fname,
        data: data
      });
      state.str.push(fname);
      neo = state;
      return self;
    }
  };
  handle.def = {};
  handle.def.fault = function(){
    return null;
  };
  handle.def.fault[uic] = print.log.def_fault;
  handle.def.ok = function(self, data){
    var state, neo, F;
    state = self[modflag];
    neo = Object.assign({}, state, {
      def: data,
      str: state.str.concat('def')
    });
    F = tightloop(neo);
    F[uic] = print.log.wrap(neo);
    return F;
  };
  genfun = function(vfun, fname){
    return function(){
      var state, ref$, zone, data;
      state = this[modflag];
      if (state.fault) {
        return this;
      }
      ref$ = vfun(arguments), zone = ref$[0], data = ref$[1];
      return handle[zone](this, data, fname);
    };
  };
  main[uic] = print.log.proto;
  main.def = function(){
    var state, ref$, zone, data;
    state = this[modflag];
    if (state.fault) {
      return handle.def.fault;
    }
    ref$ = verify.def(arguments), zone = ref$[0], data = ref$[1];
    return handle.def.ok(this, data);
  };
  props = ['ma', 'arma', 'wh', 'ar', 'whn', 'arn', 'arwh', 'arnwh', 'arwhn', 'arnwhn'];
  R.reduce(function(ob, prop){
    ob[prop] = genfun(verify.getvfun(prop), prop);
    return ob;
  }, main, props);
  hoplon = looper(init);
  hoplon.immutable = looper(Object.assign({}, init, {
    immutable: true
  }));
  hoplon.mutelog = looper(Object.assign({}, init, {
    mutelog: true
  }));
  hoplon.immutable.mutelog = looper(Object.assign({}, init, {
    immutable: true,
    mutelog: true
  }));
  hoplon.mutelog.immutable = looper(Object.assign({}, init, {
    immutable: true,
    mutelog: true
  }));
  Object.freeze(hoplon);
  reg.hoplon = hoplon;
  module.exports = hoplon;
}).call(this);
