// Generated by LiveScript 1.6.0
(function(){
  var reg, printE, verify, com, binapi, l, SI, z, noop, sim, j, merge, resolve, chain, entry, data, hoplon;
  reg = require("./registry");
  require("./print");
  require("./verify");
  printE = reg.printE, verify = reg.verify, com = reg.com;
  binapi = com.binapi, l = com.l, SI = com.SI, z = com.z, noop = com.noop, sim = com.sim, j = com.j;
  merge = function(data, p){
    return SI.merge(data, p, {
      merger: sim.concatArrayMerger
    });
  };
  resolve = function(data, input){
    var arglen, i$, ref$, len$, ref1$, fname, args, type, j$, len1$, f, ret, validator, lens, I, def;
    arglen = input.length;
    for (i$ = 0, len$ = (ref$ = data.fns).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], fname = ref1$.fname, args = ref1$.args, type = ref1$.type;
      switch (fname) {
      case 'ma':
        for (j$ = 0, len1$ = args.length; j$ < len1$; ++j$) {
          f = args[j$];
          ret = f.apply(null, input);
          if (!(ret === undefined || ret === false)) {
            return ret;
          }
        }
        break;
      case 'wh':
        validator = args[0], f = args[1];
        if (validator.apply(null, input)) {
          switch (type) {
          case 'f':
            return f.apply(null, input);
          case 's':
            return f;
          }
        }
        break;
      case 'ar':
        lens = args[0], f = args[1];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            switch (type) {
            case 'f':
              return f.apply(null, input);
            case 's':
              return f;
            }
          }
        }
        break;
      case 'whn':
        validator = args[0], f = args[1];
        if (!validator.apply(null, input)) {
          switch (type) {
          case 'f':
            return f.apply(null, input);
          case 's':
            return f;
          }
        }
        break;
      case 'arn':
        lens = args[0], f = args[1];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (!(arglen === I)) {
            switch (type) {
            case 'f':
              return f.apply(null, input);
            case 's':
              return f;
            }
          }
        }
        break;
      case 'arwh':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            if (validator.apply(null, input)) {
              switch (type) {
              case 'f':
                return f.apply(null, input);
              case 's':
                return f;
              }
              return f.apply(null, input);
            }
          }
        }
        break;
      case 'arwhn':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            if (!validator.apply(null, input)) {
              switch (type) {
              case 'f':
                return f.apply(null, input);
              case 's':
                return f;
              }
            }
          }
        }
        break;
      case 'arnwhn':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (!(arglen === I)) {
            if (!validator.apply(null, input)) {
              switch (type) {
              case 'f':
                return f.apply(null, input);
              case 's':
                return f;
              }
            }
          }
        }
      }
    }
    def = data.def;
    if (def) {
      switch (def.type) {
      case 's':
        return def.f;
      case 'f':
        return def.f.apply(def, input);
      }
    }
  };
  chain = function(state, arg$){
    var fname, type, args, part, f;
    fname = arg$[0], type = arg$[1], args = arg$[2];
    part = {};
    part.str = [fname];
    switch (fname) {
    case 'def':
      f = args[0];
      part.ldef = true;
      part.def = {
        type: type,
        f: f
      };
      break;
    default:
      part.fns = [{
        fname: fname,
        type: type,
        args: args
      }];
    }
    return binapi(entry, merge(state, part));
  };
  entry = function(path, user, state){
    var ret, cont, info;
    if (state.fault) {
      return binapi(entry, state);
    }
    ret = verify.main(path, user, state);
    cont = ret[0], info = ret[1];
    switch (cont) {
    case 're':
      return resolve(state, info);
    case 'chain':
      return chain(state, info);
    case 'fault':
      printE.route(state.str, info);
      return binapi(entry, merge(state, {
        fault: info
      }));
    }
  };
  entry.log = printE.log;
  data = {
    fns: [],
    def: null,
    ldef: false,
    fault: false,
    str: []
  };
  hoplon = binapi(entry, SI(data));
  reg.hoplon = hoplon;
  module.exports = hoplon;
}).call(this);
