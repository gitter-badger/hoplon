// Generated by LiveScript 1.6.0
(function(){
  var reg, com, already_created, verify, modflag, print, main, l, z, R, uic, init, settle, tightloop, looper, handle, genfun, props, hoplon;
  reg = require("./registry");
  require("./print");
  require("./verify");
  com = reg.com, already_created = reg.already_created, verify = reg.verify, modflag = reg.modflag, print = reg.print, main = reg.main;
  l = com.l, z = com.z, R = com.R, uic = com.uic;
  init = {
    str: [],
    fns: [],
    def: null,
    fault: false,
    unary: false,
    immutable: false
  };
  settle = function(F, A){
    var ftype, f;
    ftype = F[0], f = F[1];
    switch (ftype) {
    case 'f':
      return f.apply(null, A);
    case 's':
      return f;
    }
  };
  tightloop = function(state){
    return function(){
      var first, arglen, I, fns, terminate, ref$, fname, data, validator, fin, ret, Jn, J, spans, F, ltype, lens, has, funs, Kn, K, def;
      if (state.unary) {
        first = arguments[0];
        switch (R.type(first)) {
        case 'Arguments':
        case 'Array':
          arglen = first.length;
          break;
        default:
          print.route([['not_array'], state]);
          return undefined;
        }
      } else {
        arglen = arguments.length;
      }
      I = 0;
      fns = state.fns;
      terminate = fns.length;
      do {
        ref$ = fns[I], fname = ref$.fname, data = ref$.data;
        switch (fname) {
        case 'wh':
          validator = data[0], fin = data[1];
          if (validator.apply(null, arguments)) {
            return settle(fin, arguments);
          }
          break;
        case 'ma':
          switch (data.length) {
          case 1:
            ret = data[0].apply(data, arguments);
            if (ret) {
              return ret;
            }
            break;
          default:
            Jn = data.length;
            J = 0;
            do {
              ret = data[J].apply(data, arguments);
              if (ret) {
                return ret;
              }
              J += 1;
            } while (J < Jn);
          }
          break;
        case 'whn':
          validator = data[0], fin = data[1];
          if (!validator.apply(null, arguments)) {
            return settle(fin, arguments);
          }
          break;
        case 'ar':
          spans = data[0], F = data[1];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              return settle(F, arguments);
            }
            break;
          case 'a':
            Jn = lens.length;
            J = 0;
            do {
              if (lens[J] === arglen) {
                return settle(F, arguments);
              }
              J += 1;
            } while (J < Jn);
          }
          break;
        case 'arn':
          spans = data[0], fin = data[1];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (!(lens === arglen)) {
              return settle(fin, arguments);
            }
            break;
          case 'a':
            Jn = lens.length;
            J = 0;
            has = false;
            do {
              if (lens[J] === arglen) {
                has = true;
              }
              if (!has) {
                return settle(fin, arguments);
              }
              J += 1;
            } while (J < Jn);
          }
          break;
        case 'arwh':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              if (validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            Jn = lens.length;
            J = 0;
            do {
              if (lens[J] === arglen) {
                if (validator.apply(null, arguments)) {
                  return settle(fin, arguments);
                }
                J += 1;
              }
            } while (J < Jn);
          }
          break;
        case 'arma':
          spans = data[0], funs = data[1];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              if (funs.length === 1) {
                ret = funs[0].apply(funs, arguments);
                if (ret) {
                  return ret;
                }
              } else {
                Jn = funs.length;
                J = 0;
                do {
                  ret = funs[J].apply(funs, arguments);
                  if (ret) {
                    return ret;
                    J += 1;
                  }
                } while (J < Jn);
              }
            }
            break;
          case 'a':
            spans = data[0], funs = data[1];
            ltype = spans[0], lens = spans[1];
            Jn = lens.length;
            J = 0;
            do {
              if (lens[J] === arglen) {
                if (funs.length === 1) {
                  ret = funs[0].apply(funs, arguments);
                  if (ret) {
                    return ret;
                  }
                } else {
                  Kn = funs.length;
                  K = 0;
                  do {
                    ret = funs[K].apply(funs, arguments);
                    if (ret) {
                      return ret;
                    }
                    K += 1;
                  } while (K < Kn);
                }
              }
              J += 1;
            } while (J < Jn);
          }
          break;
        case 'arwhn':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (lens === arglen) {
              if (!validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            Jn = lens.length;
            J = 0;
            do {
              if (lens[J] === arglen) {
                if (!validator.apply(null, arguments)) {
                  return settle(fin, arguments);
                }
              }
              J += 1;
            } while (J < Jn);
          }
          break;
        case 'arnwh':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (!(lens === arglen)) {
              if (settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            Jn = lens.length;
            J = 0;
            has = false;
            do {
              if (lens[J] === arglen) {
                has = true;
              }
              J += 1;
            } while (J < Jn);
            if (!has) {
              if (settle(validator, arguments)) {
                return settle(fin, arguments);
              }
            }
          }
          break;
        case 'arnwhn':
          spans = data[0], validator = data[1], fin = data[2];
          ltype = spans[0], lens = spans[1];
          switch (ltype) {
          case 'n':
            if (!(lens === arglen)) {
              if (!validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
            break;
          case 'a':
            Jn = lens.length;
            J = 0;
            has = false;
            do {
              if (lens[J] === arglen) {
                has = true;
              }
              J += 1;
            } while (J < Jn);
            if (!has) {
              if (!validator.apply(null, arguments)) {
                return settle(fin, arguments);
              }
            }
          }
        }
        I += 1;
      } while (I < terminate);
      def = state.def;
      if (def) {
        switch (def[0]) {
        case 'f':
          return def[1].apply(def, arguments);
        case 's':
          return def[1];
        }
      }
    };
  };
  looper = function(state){
    var instance;
    instance = Object.create(main);
    instance[modflag] = state;
    return instance;
  };
  handle = {};
  handle.fault = function(self, data, fname){
    var state, FT, neo;
    state = self[modflag];
    FT = ['input', fname, data];
    print.route([FT, state]);
    neo = Object.assign({}, state, {
      fault: FT
    });
    return looper(neo);
  };
  handle.ok = function(self, data, fname){
    var state, fns, neo;
    state = self[modflag];
    if (state.immutable || state.str.length === 0) {
      fns = state.fns.concat({
        fname: fname,
        data: data
      });
      neo = Object.assign({}, state, {
        fns: fns,
        str: state.str.concat(fname)
      });
      return looper(neo);
    } else {
      state.fns.push({
        fname: fname,
        data: data
      });
      state.str.push(fname);
      neo = state;
      return self;
    }
  };
  handle.def = {};
  handle.def.fault = function(){
    return null;
  };
  handle.def.fault[uic] = print.log.def_fault;
  handle.def.ok = function(self, data){
    var state, neo, F;
    state = self[modflag];
    neo = Object.assign({}, state, {
      def: data,
      str: state.str
    });
    F = tightloop(neo);
    F[uic] = print.log.wrap(neo);
    return F;
  };
  genfun = function(vfun, fname){
    return function(){
      var state, ref$, zone, data;
      state = this[modflag];
      if (state.fault) {
        return this;
      }
      ref$ = vfun(arguments), zone = ref$[0], data = ref$[1];
      return handle[zone](this, data, fname);
    };
  };
  main[uic] = print.log.proto;
  main.def = function(){
    var state, ref$, zone, data;
    state = this[modflag];
    if (state.fault) {
      return handle.def.fault;
    }
    ref$ = verify.def(arguments), zone = ref$[0], data = ref$[1];
    return handle.def.ok(this, data);
  };
  props = ['ma', 'arma', 'wh', 'ar', 'whn', 'arn', 'arwh', 'arnwh', 'arwhn', 'arnwhn'];
  R.reduce(function(ob, prop){
    ob[prop] = genfun(verify.getvfun(prop), prop);
    return ob;
  }, main, props);
  hoplon = looper(init);
  hoplon.immutable = looper(Object.assign({}, init, {
    immutable: true
  }));
  hoplon.unary = looper(Object.assign({}, init, {
    unary: true
  }));
  hoplon.immutable.unary = looper(Object.assign({}, init, {
    immutable: true,
    unary: true
  }));
  hoplon.unary.immutable = looper(Object.assign({}, init, {
    immutable: true,
    unary: true
  }));
  Object.freeze(hoplon);
  reg.hoplon = hoplon;
  module.exports = hoplon;
}).call(this);
