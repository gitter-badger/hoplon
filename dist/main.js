// Generated by LiveScript 1.6.0
(function(){
  var com, binapi, l, SI, z, reg, noop, sim, j, verify, printE, merge, resolve, main, entry, data, hoplon;
  com = require("./common");
  require("./verify");
  require("./print");
  binapi = com.binapi, l = com.l, SI = com.SI, z = com.z, reg = com.reg, noop = com.noop, sim = com.sim, j = com.j;
  verify = reg.verify, printE = reg.printE;
  merge = function(data, p){
    return SI.merge(data, p, {
      merger: sim.concatArrayMerger
    });
  };
  resolve = function(data, input){
    var arglen, i$, ref$, len$, ref1$, fname, args, lens, f, j$, len1$, I, validator;
    arglen = input.length;
    for (i$ = 0, len$ = (ref$ = data.fns).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], fname = ref1$[0], args = ref1$[1];
      switch (fname) {
      case 'ar':
        lens = args[0], f = args[1];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            return f.apply(null, input);
          }
        }
        break;
      case 'arn':
        lens = args[0], f = args[1];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (!(arglen === I)) {
            return f.apply(null, input);
          }
        }
        break;
      case 'wh':
        validator = args[0], f = args[1];
        if (validator.apply(null, input)) {
          return f.apply(null, input);
        }
        break;
      case 'whn':
        validator = args[0], f = args[1];
        if (!validator.apply(null, input)) {
          return f.apply(null, input);
        }
        break;
      case 'arwh':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            if (validator.apply(null, input)) {
              return f.apply(null, input);
            }
          }
        }
        break;
      case 'arwhn':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (arglen === I) {
            if (!validator.apply(null, input)) {
              return f.apply(null, input);
            }
          }
        }
        break;
      case 'arnwhn':
        lens = args[0], validator = args[1], f = args[2];
        for (j$ = 0, len1$ = lens.length; j$ < len1$; ++j$) {
          I = lens[j$];
          if (!(arglen === I)) {
            if (!validator.apply(null, input)) {
              return f.apply(null, input);
            }
          }
        }
      }
    }
    if (data.def) {
      return data.def.apply(data, input);
    }
  };
  main = function(data, fname, args){
    var part, neo, f;
    switch (fname) {
    case 'resolve':
      return resolve(data, args);
    }
    part = {};
    part.str = [fname];
    neo = (function(){
      switch (fname) {
      case 'def':
        f = args[0];
        part.ldef = true;
        part.def = f;
        return merge(data, part);
      default:
        part.fns = [[fname, args]];
        return merge(data, part);
      }
    }());
    return binapi(entry, neo);
  };
  entry = function(path, args, data){
    var ret, cont, fname;
    if (data.fault) {
      return binapi(entry, data);
    }
    ret = verify.main(path, args, data);
    cont = ret[0], fname = ret[1], args = ret[2];
    switch (cont) {
    case 'fault':
      printE.route(data.str, ret);
      return binapi(entry, merge(data, {
        fault: ret
      }));
    default:
      return main(data, fname, args);
    }
  };
  entry.log = printE.log;
  data = {
    fns: [],
    def: null,
    ldef: false,
    fault: false,
    str: [],
    self: null
  };
  hoplon = binapi(entry, SI(data));
  module.exports = hoplon;
}).call(this);
